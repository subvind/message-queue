# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/message-queue/src/message-broker/message-broker.controller.ts">

import { Controller, Post, Body, Get, Param } from '@nestjs/common';
import { MessageBrokerService } from './message-broker.service';

@Controller('message-broker')
export class MessageBrokerController {
  constructor(private readonly messageBrokerService: MessageBrokerService) {}

  @Post('exchange')
  createExchange(@Body('name') name: string) {
    this.messageBrokerService.createExchange(name);
    return { status: 'ok', message: `Exchange ${name} created` };
  }

  @Post('bind')
  bind(
    @Body('exchange') exchange: string,
    @Body('queue') queue: string,
    @Body('routingKey') routingKey: string,
  ) {
    const result = this.messageBrokerService.bind(exchange, queue, routingKey);
    return result
      ? { status: 'ok', message: 'Binding created' }
      : { status: 'error', message: 'Exchange not found' };
  }

  @Post('publish')
  publish(
    @Body('exchange') exchange: string,
    @Body('routingKey') routingKey: string,
    @Body('message') message: any,
  ) {
    const result = this.messageBrokerService.publish(exchange, routingKey, message);
    return result
      ? { status: 'ok', message: 'Message published' }
      : { status: 'error', message: 'Exchange not found' };
  }

  @Get('consume/:exchange/:queue')
  async consume(
    @Param('exchange') exchange: string,
    @Param('queue') queue: string,
  ) {
    const message = await this.messageBrokerService.consume(exchange, queue);
    return message
      ? { status: 'ok', message }
      : { status: 'error', message: 'No message available or exchange/queue not found' };
  }

  @Get('queue-length/:exchange/:queue')
  async getQueueLength(
    @Param('exchange') exchange: string,
    @Param('queue') queue: string,
  ) {
    const length = await this.messageBrokerService.getQueueLength(exchange, queue);
    return { status: 'ok', length };
  }
}
</FILE>
<FILE path="/home/travis/Projects/message-queue/src/message-broker/message-broker.gateway.ts">
import {
  WebSocketGateway,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
  WebSocketServer,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { MessageBrokerService } from './message-broker.service';

@WebSocketGateway()
export class MessageBrokerGateway {
  @WebSocketServer()
  server: Server;

  private subscriptions: Map<Socket, Set<string>> = new Map();

  constructor(private readonly messageBrokerService: MessageBrokerService) {
    this.subscribeToAllExchanges();
  }

  private subscribeToAllExchanges() {
    this.messageBrokerService.onMessage((exchange, queue, message) => {
      this.server.sockets.sockets.forEach((socket: Socket) => {
        const subscriptionKey = `${exchange}:${queue}`;
        if (this.subscriptions.get(socket)?.has(subscriptionKey)) {
          socket.emit('message', { exchange, queue, message });
        }
      });
    });
  }

  @SubscribeMessage('subscribe')
  handleSubscribe(
    @MessageBody() data: { exchange: string; queue: string },
    @ConnectedSocket() client: Socket,
  ) {
    const { exchange, queue } = data;
    const subscriptionKey = `${exchange}:${queue}`;

    if (!this.subscriptions.has(client)) {
      this.subscriptions.set(client, new Set());
    }

    this.subscriptions.get(client).add(subscriptionKey);

    const success = this.messageBrokerService.subscribe(exchange, queue, (message) => {
      client.emit('message', { exchange, queue, message });
    });

    if (success) {
      client.on('disconnect', () => {
        this.subscriptions.delete(client);
        this.messageBrokerService.unsubscribe(exchange, queue, () => {});
      });
      return { status: 'ok', message: 'Subscribed successfully' };
    } else {
      return { status: 'error', message: 'Failed to subscribe' };
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/message-queue/src/message-broker/message-broker.service.ts">
import { Injectable } from '@nestjs/common';
import { MessageStorageService } from '../message-storage/message-storage.service';
import { Exchange } from '../exchange/exchange';
import { EventEmitter } from 'events';

@Injectable()
export class MessageBrokerService {
  private exchanges: Map<string, Exchange> = new Map();
  private eventEmitter: EventEmitter = new EventEmitter();

  constructor(private messageStorage: MessageStorageService) {}

  createExchange(name: string): Exchange {
    const exchange = new Exchange(name, this.messageStorage);
    this.exchanges.set(name, exchange);
    return exchange;
  }

  getExchange(name: string): Exchange | undefined {
    return this.exchanges.get(name);
  }

  async publish(exchangeName: string, routingKey: string, message: any): Promise<boolean> {
    const exchange = this.getExchange(exchangeName);
    if (exchange) {
      await exchange.publish(routingKey, message);
      this.eventEmitter.emit('message', exchangeName, routingKey, message);
      return true;
    }
    return false;
  }

  async consume(exchangeName: string, queueName: string): Promise<any> {
    const exchange = this.getExchange(exchangeName);
    if (exchange) {
      return await exchange.consume(queueName);
    }
    return null;
  }

  bind(exchangeName: string, queueName: string, routingKey: string): boolean {
    const exchange = this.getExchange(exchangeName);
    if (exchange) {
      exchange.bind(queueName, routingKey);
      return true;
    }
    return false;
  }

  subscribe(exchangeName: string, queueName: string, callback: (message: any) => void): boolean {
    const exchange = this.getExchange(exchangeName);
    if (exchange) {
      exchange.subscribe(queueName, callback);
      return true;
    }
    return false;
  }

  unsubscribe(exchangeName: string, queueName: string, callback: (message: any) => void): boolean {
    const exchange = this.getExchange(exchangeName);
    if (exchange) {
      exchange.unsubscribe(queueName, callback);
      return true;
    }
    return false;
  }

  async getQueueLength(exchangeName: string, queueName: string): Promise<number> {
    return await this.messageStorage.getQueueLength(exchangeName, queueName);
  }

  onMessage(callback: (exchange: string, queue: string, message: any) => void) {
    this.eventEmitter.on('message', callback);
  }
}
</FILE>
<FILE path="/home/travis/Projects/message-queue/src/message-storage/message-storage.service.ts">
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import Redis from 'ioredis';

@Injectable()
export class MessageStorageService implements OnModuleInit, OnModuleDestroy {
  private redisClient: Redis;

  async onModuleInit() {
    this.redisClient = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
    });
  }

  async onModuleDestroy() {
    await this.redisClient.quit();
  }

  private getQueueKey(exchangeName: string, queueName: string): string {
    return `${exchangeName}:${queueName}`;
  }

  async saveMessage(exchangeName: string, queueName: string, message: any): Promise<void> {
    const queueKey = this.getQueueKey(exchangeName, queueName);
    await this.redisClient.rpush(queueKey, JSON.stringify({
      timestamp: Date.now(),
      content: message
    }));
  }

  async getMessages(exchangeName: string, queueName: string, count: number = 1): Promise<any[]> {
    const queueKey = this.getQueueKey(exchangeName, queueName);
    const messages = await this.redisClient.lrange(queueKey, 0, count - 1);
    return messages.map(msg => JSON.parse(msg));
  }

  async removeMessage(exchangeName: string, queueName: string): Promise<any> {
    const queueKey = this.getQueueKey(exchangeName, queueName);
    return JSON.parse(await this.redisClient.lpop(queueKey));
  }

  async getQueueLength(exchangeName: string, queueName: string): Promise<number> {
    const queueKey = this.getQueueKey(exchangeName, queueName);
    return await this.redisClient.llen(queueKey);
  }
}

</FILE>
<FILE path="/home/travis/Projects/message-queue/src/exchange/exchange.ts">
import { MessageStorageService } from '../message-storage/message-storage.service';
import { Queue } from 'src/queue/queue';

export class Exchange {
  private queues: Map<string, Queue> = new Map();

  constructor(
    private name: string,
    private messageStorage: MessageStorageService
  ) {}

  bind(queueName: string, routingKey: string) {
    if (!this.queues.has(queueName)) {
      this.queues.set(queueName, new Queue(this.name, queueName, this.messageStorage));
    }
  }

  async publish(routingKey: string, message: any) {
    const targetQueue = this.queues.get(routingKey);
    if (targetQueue) {
      await targetQueue.enqueue(message);
    }
  }

  async consume(queueName: string): Promise<any> {
    const queue = this.queues.get(queueName);
    if (queue) {
      return await queue.dequeue();
    }
    return null;
  }

  subscribe(queueName: string, callback: (message: any) => void) {
    const queue = this.queues.get(queueName);
    if (queue) {
      queue.subscribe(callback);
    }
  }

  unsubscribe(queueName: string, callback: (message: any) => void) {
    const queue = this.queues.get(queueName);
    if (queue) {
      queue.unsubscribe(callback);
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/message-queue/src/queue/queue.ts">
import { EventEmitter } from 'events';
import { MessageStorageService } from '../message-storage/message-storage.service';

export class Queue {
  private eventEmitter = new EventEmitter();

  constructor(
    private exchangeName: string,
    private queueName: string,
    private messageStorage: MessageStorageService
  ) {}

  async enqueue(message: any) {
    await this.messageStorage.saveMessage(this.exchangeName, this.queueName, message);
    this.eventEmitter.emit('message', message);
  }

  async dequeue(): Promise<any> {
    const message = await this.messageStorage.removeMessage(this.exchangeName, this.queueName);
    if (message) {
      return message.content;
    }
    
    return new Promise((resolve) => {
      this.eventEmitter.once('message', async (newMessage) => {
        await this.messageStorage.removeMessage(this.exchangeName, this.queueName);
        resolve(newMessage);
      });
    });
  }

  subscribe(callback: (message: any) => void) {
    this.eventEmitter.on('message', callback);
  }

  unsubscribe(callback: (message: any) => void) {
    this.eventEmitter.off('message', callback);
  }
}

</FILE>
<FILE path="/home/travis/Projects/message-queue/src/app.module.ts">
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { MessageBrokerModule } from './message-broker/message-broker.module';

@Module({
  imports: [MessageBrokerModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

</FILE>
<FILE path="/home/travis/Projects/message-queue/test:message-routing.stdout.txt">
Exchange 'exchange1' created
Exchange 'exchange2' created
Queue 'queue1' bound to exchange 'exchange1'
Queue 'queue2' bound to exchange 'exchange1'
Queue 'queue3' bound to exchange 'exchange2'
Queue 'queue4' bound to exchange 'exchange2'
Connected to WebSocket server
Subscription response for exchange1/queue1: { status: 'ok', message: 'Subscribed successfully' }
Subscription response for exchange1/queue2: { status: 'ok', message: 'Subscribed successfully' }
Subscription response for exchange2/queue3: { status: 'ok', message: 'Subscribed successfully' }
Subscription response for exchange2/queue4: { status: 'ok', message: 'Subscribed successfully' }
Published message to exchange 'exchange1', queue 'queue1': Message 1 for Queue 1
Received message via WebSocket from exchange1/queue1: Message 1 for Queue 1
Received message via WebSocket from exchange1/queue1: Message 1 for Queue 1
Published message to exchange 'exchange1', queue 'queue2': Message 1 for Queue 2
Received message via WebSocket from exchange1/queue2: Message 1 for Queue 2
Received message via WebSocket from exchange1/queue2: Message 1 for Queue 2
Published message to exchange 'exchange2', queue 'queue3': Message 1 for Queue 3
Received message via WebSocket from exchange2/queue3: Message 1 for Queue 3
Received message via WebSocket from exchange2/queue3: Message 1 for Queue 3
Published message to exchange 'exchange2', queue 'queue4': Message 1 for Queue 4
Received message via WebSocket from exchange2/queue4: Message 1 for Queue 4
Received message via WebSocket from exchange2/queue4: Message 1 for Queue 4
Published message to exchange 'exchange1', queue 'queue1': Message 2 for Queue 1
Received message via WebSocket from exchange1/queue1: Message 2 for Queue 1
Received message via WebSocket from exchange1/queue1: Message 2 for Queue 1
Published message to exchange 'exchange1', queue 'queue2': Message 2 for Queue 2
Received message via WebSocket from exchange1/queue2: Message 2 for Queue 2
Received message via WebSocket from exchange1/queue2: Message 2 for Queue 2
Published message to exchange 'exchange2', queue 'queue3': Message 2 for Queue 3
Received message via WebSocket from exchange2/queue3: Message 2 for Queue 3
Received message via WebSocket from exchange2/queue3: Message 2 for Queue 3
Published message to exchange 'exchange2', queue 'queue4': Message 2 for Queue 4
Received message via WebSocket from exchange2/queue4: Message 2 for Queue 4
Received message via WebSocket from exchange2/queue4: Message 2 for Queue 4
Published message to exchange 'exchange1', queue 'queue1': Message 3 for Queue 1
Received message via WebSocket from exchange1/queue1: Message 3 for Queue 1
Received message via WebSocket from exchange1/queue1: Message 3 for Queue 1
Published message to exchange 'exchange1', queue 'queue2': Message 3 for Queue 2
Received message via WebSocket from exchange1/queue2: Message 3 for Queue 2
Received message via WebSocket from exchange1/queue2: Message 3 for Queue 2
Published message to exchange 'exchange2', queue 'queue3': Message 3 for Queue 3
Received message via WebSocket from exchange2/queue3: Message 3 for Queue 3
Received message via WebSocket from exchange2/queue3: Message 3 for Queue 3
Published message to exchange 'exchange1', queue 'queue1': Message 4 for Queue 1
Received message via WebSocket from exchange1/queue1: Message 4 for Queue 1
Received message via WebSocket from exchange1/queue1: Message 4 for Queue 1
Published message to exchange 'exchange1', queue 'queue2': Message 4 for Queue 2
Received message via WebSocket from exchange1/queue2: Message 4 for Queue 2
Received message via WebSocket from exchange1/queue2: Message 4 for Queue 2
Published message to exchange 'exchange1', queue 'queue1': Message 5 for Queue 1
Received message via WebSocket from exchange1/queue1: Message 5 for Queue 1
Received message via WebSocket from exchange1/queue1: Message 5 for Queue 1

Summary of received messages:
exchange1/queue1: 10 message(s)
  1. Message 1 for Queue 1
  2. Message 1 for Queue 1
  3. Message 2 for Queue 1
  4. Message 2 for Queue 1
  5. Message 3 for Queue 1
  6. Message 3 for Queue 1
  7. Message 4 for Queue 1
  8. Message 4 for Queue 1
  9. Message 5 for Queue 1
  10. Message 5 for Queue 1
exchange1/queue2: 8 message(s)
  1. Message 1 for Queue 2
  2. Message 1 for Queue 2
  3. Message 2 for Queue 2
  4. Message 2 for Queue 2
  5. Message 3 for Queue 2
  6. Message 3 for Queue 2
  7. Message 4 for Queue 2
  8. Message 4 for Queue 2
exchange2/queue3: 6 message(s)
  1. Message 1 for Queue 3
  2. Message 1 for Queue 3
  3. Message 2 for Queue 3
  4. Message 2 for Queue 3
  5. Message 3 for Queue 3
  6. Message 3 for Queue 3
exchange2/queue4: 4 message(s)
  1. Message 1 for Queue 4
  2. Message 1 for Queue 4
  3. Message 2 for Queue 4
  4. Message 2 for Queue 4

Message routing test completed.

</FILE>
<FILE path="/home/travis/Projects/message-queue/src/main.ts">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3030);
}
bootstrap();

</FILE>
<FILE path="test/test-message-routing.ts" TARGET>
import axios from 'axios';
import { io, Socket } from 'socket.io-client';

const baseUrl = 'http://localhost:3030/message-broker';
const wsUrl = 'http://localhost:3030';

async function createExchange(name: string) {
  await axios.post(`${baseUrl}/exchange`, { name });
  console.log(`Exchange '${name}' created`);
}

async function bindQueue(exchange: string, queue: string) {
  await axios.post(`${baseUrl}/bind`, {
    exchange,
    queue,
    routingKey: queue
  });
  console.log(`Queue '${queue}' bound to exchange '${exchange}'`);
}

async function publishMessage(exchange: string, queue: string, message: string) {
  await axios.post(`${baseUrl}/publish`, {
    exchange,
    routingKey: queue,
    message
  });
  console.log(`Published message to exchange '${exchange}', queue '${queue}': ${message}`);
}

function createWebSocketClient(): Promise<Socket> {
  return new Promise((resolve) => {
    const socket = io(wsUrl);
    socket.on('connect', () => {
      console.log('Connected to WebSocket server');
      resolve(socket);
    });
  });
}

function subscribeToQueue(socket: Socket, exchange: string, queue: string): Promise<void> {
  return new Promise((resolve) => {
    socket.emit('subscribe', { exchange, queue }, (response) => {
      console.log(`Subscription response for ${exchange}/${queue}:`, response);
      resolve();
    });
  });
}

async function testMessageRouting() {
  try {
    // Create exchanges
    await createExchange('exchange1');
    await createExchange('exchange2');

    // Bind queues
    await bindQueue('exchange1', 'queue1');
    await bindQueue('exchange1', 'queue2');
    await bindQueue('exchange2', 'queue3');
    await bindQueue('exchange2', 'queue4');

    // Create WebSocket client
    const socket = await createWebSocketClient();

    // Subscribe to all queues
    await subscribeToQueue(socket, 'exchange1', 'queue1');
    await subscribeToQueue(socket, 'exchange1', 'queue2');
    await subscribeToQueue(socket, 'exchange2', 'queue3');
    await subscribeToQueue(socket, 'exchange2', 'queue4');

    // Set up message listener
    const receivedMessages: { [key: string]: string[] } = {};
    socket.on('message', (data) => {
      const key = `${data.exchange}/${data.queue}`;
      if (!receivedMessages[key]) {
        receivedMessages[key] = [];
      }
      receivedMessages[key].push(data.message);
      console.log(`Received message via WebSocket from ${key}:`, data.message);
    });

    // Publish messages
    await publishMessage('exchange1', 'queue1', 'Message 1 for Queue 1');
    await publishMessage('exchange1', 'queue2', 'Message 1 for Queue 2');
    await publishMessage('exchange2', 'queue3', 'Message 1 for Queue 3');
    await publishMessage('exchange2', 'queue4', 'Message 1 for Queue 4');
    await publishMessage('exchange1', 'queue1', 'Message 2 for Queue 1');
    await publishMessage('exchange1', 'queue2', 'Message 2 for Queue 2');
    await publishMessage('exchange2', 'queue3', 'Message 2 for Queue 3');
    await publishMessage('exchange2', 'queue4', 'Message 2 for Queue 4');
    await publishMessage('exchange1', 'queue1', 'Message 3 for Queue 1');
    await publishMessage('exchange1', 'queue2', 'Message 3 for Queue 2');
    await publishMessage('exchange2', 'queue3', 'Message 3 for Queue 3');
    await publishMessage('exchange1', 'queue1', 'Message 4 for Queue 1');
    await publishMessage('exchange1', 'queue2', 'Message 4 for Queue 2');
    await publishMessage('exchange1', 'queue1', 'Message 5 for Queue 1');

    // Wait for messages to be received
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Print summary of received messages
    console.log('\nSummary of received messages:');
    for (const [key, messages] of Object.entries(receivedMessages)) {
      console.log(`${key}: ${messages.length} message(s)`);
      messages.forEach((msg, index) => {
        console.log(`  ${index + 1}. ${msg}`);
      });
    }

    // Close WebSocket connection
    socket.close();
    console.log('\nMessage routing test completed.');
  } catch (error) {
    console.error('Error:', error.response ? error.response.data : error.message);
  }
}

testMessageRouting();
</FILE>
<REQUEST>
there should not be duplicate messages consumed in stdout for each published message
</REQUEST>